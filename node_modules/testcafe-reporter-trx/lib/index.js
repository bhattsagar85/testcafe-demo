'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});
var TRX = require('node-trx');
var os = require('os');

var computerName = os.hostname();
var userName = os.userInfo().username;
var TestRun = TRX.TestRun;
var UnitTest = TRX.UnitTest;
var newLine = os.EOL;

exports['default'] = function () {
    return {
        noColors: true,

        reportTaskStart: function reportTaskStart(startTime /*, userAgents, testCount*/) {
            this.startTime = startTime;
            this.tests = [];
        },

        reportFixtureStart: function reportFixtureStart(name, path) {
            this.fixtureName = name;
            this.path = path;
        },

        reportTestDone: function reportTestDone(name, testRunInfo) {
            var end = new Date(+this.startTime + testRunInfo.durationMs);
            var hasErr = !!testRunInfo.errs.length;
            var result = hasErr ? 'Failed' : 'Passed';

            result = testRunInfo.skipped ? 'Skipped' : result;
            var testResults = {};

            testResults.name = 'test "' + name + '" in fixture "' + this.fixtureName + '"';
            if (hasErr) testResults.errs = testRunInfo.errs;
            testResults.outcome = result;
            testResults.duration = testRunInfo.durationMs;
            testResults.start = this.testStartTime;
            testResults.end = end;
            this.tests.push(testResults);
        },

        reportTaskDone: function reportTaskDone(endTime /*, passed, warnings*/) {
            var _this = this;

            var now = endTime.toISOString();
            var testRunName = userName + '@' + computerName + ' ' + now.substring(0, now.indexOf('.')).replace('T', ' ');
            var run = new TestRun({
                name: testRunName,
                runUser: userName,
                settings: {
                    name: 'default'
                },
                times: {
                    creation: now,
                    queuing: now,
                    start: this.startTime.toISOString(),
                    finish: endTime.toISOString()
                }
            });

            this.tests.map(function (test) {
                var unittest = new UnitTest({
                    name: test.name,
                    methodCodeBase: 'none',
                    methodName: 'none',
                    methodClassName: 'none'
                });
                var errorMessage = test.errs ? test.name + ' encountered errors' : '';
                var errorStacktrace = '';

                if (test.errs) {
                    test.errs.map(function (err, idx) {
                        var prefix = _this.chalk.red(idx + 1 + ') ');

                        errorStacktrace += _this.formatError(err, prefix) + newLine;
                    });
                }

                run.addResult({
                    test: unittest,
                    computerName: computerName,
                    outcome: test.outcome,
                    duration: formatDuration(test.duration || 0),
                    startTime: test.start && test.start.toISOString() || '',
                    endTime: test.end && test.end.toISOString() || '',
                    errorMessage: errorMessage,
                    errorStacktrace: errorStacktrace
                });
            });
            this.write(run.toXml());
        }
    };
};

function formatDuration(milliseconds) {
    // we get duration ISO string
    var duration = new Date(milliseconds).toISOString();

    // we return time part only and remove Z char
    return duration.substring(duration.indexOf('T') + 1).replace('Z', '');
}
module.exports = exports['default'];